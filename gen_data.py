import os
import numpy as np
import pickle
import multiprocessing as mp

bitsA = 8
bitsW = 2
n_layers = 8
w_res = 2
w_scale = 2

def load_transformed_matrix(filename):
    return np.load(filename).astype(np.int)

def save_transformed_matrix(input_matrix, filename):
    np.save(filename, input_matrix)

def transform_matrix_weight(input_matrix, length, scale=None):
    cout = input_matrix.shape[-1]
    weight_matrix = input_matrix.reshape(-1, cout)
    filled_matrix_b = np.zeros([weight_matrix.shape[0], weight_matrix.shape[1] * length], dtype=np.str)
    filled_matrix_bin = dec2bin(weight_matrix[:], length, scale)
    for i, b in enumerate(filled_matrix_bin):
        filled_matrix_b[:, i::length] = b
    return filled_matrix_b

def transform_matrix_activation_conv(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[2], input_shape[1] * length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i::length] = b.transpose()
    return filled_matrix_b

def transform_matrix_activation_fc(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[1], length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i] = b
    return filled_matrix_b
    
def stretch_input(input_matrix, window_size, stride=1):
    input_shape = input_matrix.shape
    row_num = (input_shape[2] - window_size) // stride + 1
    col_num = (input_shape[3] - window_size) // stride + 1
    assert((row_num - 1) * stride + window_size == input_shape[2])
    assert((col_num - 1) * stride + window_size == input_shape[3])
    item_num = row_num * col_num
    output_matrix = np.zeros((input_shape[0], item_num, input_shape[1]*window_size*window_size))
    iter = 0
    for i in range(row_num):
        for j in range(col_num):
            for b in range(input_shape[0]):
                output_matrix[b, iter, :] = input_matrix[b, :, i:i+window_size,j: j+window_size].transpose(1,2,0).reshape(input_shape[1]*window_size*window_size)
            iter += 1
    return output_matrix

def compute_scale_list(n):
    scale_list = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    scale_list.append(-base * delta)
    for _ in range(n-1):
        base /= 2
        scale_list.append(base * delta)
    return scale_list
    
def dec2bin(x, n, scale_list=None):
    if not scale_list:
        scale_list = compute_scale_list(n)
    y = x.copy()
    out = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    x_int = x/delta
    y[x_int>=0] = 0
    y[x_int< 0] = 1
    rest = x_int + base*y
    out.append(y.copy())
    for _ in range(n-1):
        base = base/2
        y[rest>=base] = 1
        y[rest< base]  = 0
        rest = rest - base * y
        out.append(y.copy())
    return out

def adjust_signed_computation(vector):
    vector = vector.copy()
    n_batches = vector.shape[0]
    len_vec = vector.shape[1]
    n_vec = vector.shape[2] // bitsA
    assert(vector.shape[2] % bitsA == 0)
    in_vector = np.zeros((n_batches, len_vec, n_vec*(bitsA-1)), np.int)
    for b in range(n_batches):
        sliced_vectors = []
        for j in range(n_vec):
            sliced_vector = vector[b, :, j*bitsA:(j+1)*bitsA]
            for i in range(len_vec):
                if sliced_vector[i, 0] == 1:
                    sliced_vector[i, 0] = 0
                    for j in range(1, bitsA):
                        if sliced_vector[i, j] == 0:
                            sliced_vector[i, j] = -1
                        else:
                            sliced_vector[i, j] = 0
                    for j in range(bitsA - 1, -1, -1):
                        if sliced_vector[i, j] == 0:
                            sliced_vector[i, j] = -1
                            break
                        else:
                            sliced_vector[i, j] = 0
                    assert(sliced_vector[i, 0] == 0)
            sliced_vectors.append(sliced_vector[:, 1:])
        in_vector[b, :, :] = np.hstack(sliced_vectors)
    return in_vector

def adjust_weight_resolution(input_matrix):
    input_matrix = input_matrix.copy()
    height = input_matrix.shape[0]
    out_ch = input_matrix.shape[1] // bitsW
    in_matrix = []
    for i in range(height):
        ms = []
        for j in range(out_ch):
            m = input_matrix[i, j*bitsW:(j+1)*bitsW]
            if m[0] == 1:
                m[0] = 0
                for n in range(1, bitsW):
                    if m[n] == 0:
                        m[n] = -1
                    else:
                        m[n] = 0
                for n in range(bitsW - 1, -1, -1):
                    if m[n] == 0:
                        m[n] = -1
                        break
                    else:
                        m[n] = 0
                assert(m[0] == 0)
            for k in range(bitsW//w_res):
                mm = m[k*w_res:(k+1)*w_res]
                value = 0
                for n in range(w_res):
                    value += mm[w_res-1-n] * (w_scale ** n)
                ms.append(value)
        in_matrix.append(ms)
    in_matrix = np.array(in_matrix, np.int)
    return in_matrix

scale_a = compute_scale_list(bitsA)
scale_w = compute_scale_list(bitsW)

def transform_and_save_data_subf(i, (input, weight)):
    output_path = './layer_record/'
    input_file_name = 'input_layer' + str(i) + '.npy'
    weight_file_name = 'weight_layer' + str(i) + '.npy'
    transformed_weight = transform_matrix_weight(weight, bitsW, scale_w)
    save_transformed_matrix(transformed_weight, output_path + weight_file_name)
    if len(weight.shape) > 2:
        k = weight.shape[0]
        transformed_activation = transform_matrix_activation_conv(stretch_input(input, k), bitsA, scale_a)
        save_transformed_matrix(transformed_activation, output_path + input_file_name)
    else:
        transformed_activation = transform_matrix_activation_fc(input, bitsA, scale_a)
        save_transformed_matrix(transformed_activation, output_path + input_file_name)
    signed_transformed_activation = adjust_signed_computation(transformed_activation)
    signed_input_file_name = 'signed_' + input_file_name
    save_transformed_matrix(signed_transformed_activation, output_path + signed_input_file_name)

def transform_and_save_data():
    output_path = './layer_record/'
    with open(output_path + 'H.bin','rb') as fileH:
        IN = pickle.load(fileH)
    with open(output_path + 'W.bin','rb') as fileW:
        W = pickle.load(fileW)

    pool = mp.Pool()
    for i,(input,weight) in enumerate(zip(IN,W)):
        pool.apply_async(transform_and_save_data_subf, args = (i, (input, weight)))
    pool.close()
    pool.join()

def extract_and_save_part_of_batches_subf(i):
    output_path = './layer_record/'
    input_file_name = 'signed_input_layer' + str(i) + '.npy'
    signed_transformed_activation = load_transformed_matrix(output_path + input_file_name)
    output_file_name = 'signed_input_layer' + str(i) + '_part0.npy'
    save_transformed_matrix(signed_transformed_activation[:2], output_path + output_file_name)

def extract_and_save_part_of_batches():
    pool = mp.Pool()
    for i in range(n_layers):
        pool.apply_async(extract_and_save_part_of_batches_subf, args = (i, ))
    pool.close()
    pool.join()

def transform_and_save_signed_weight_matrices_subf(i):
    output_path = './layer_record/'
    input_file_name = 'weight_layer' + str(i) + '.npy'
    transformed_weight = load_transformed_matrix(output_path + input_file_name)
    signed_transformed_weight = adjust_weight_resolution(transformed_weight)
    output_file_name = 'signed_weight_layer' + str(i) + '.npy'
    save_transformed_matrix(signed_transformed_weight, output_path + output_file_name)

def transform_and_save_signed_weight_matrices():
    pool = mp.Pool()
    for i in range(n_layers):
        pool.apply_async(transform_and_save_signed_weight_matrices_subf, args = (i, ))
    pool.close()
    pool.join()

def main():
    #transform_and_save_data()
    #extract_and_save_part_of_batches()
    transform_and_save_signed_weight_matrices()

if __name__ == "__main__":
    main()
