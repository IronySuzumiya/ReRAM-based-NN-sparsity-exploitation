import os
import numpy as np
import pickle

bitsA = 8
bitsW = 2
n_layers = 8

def save_transformed_matrix(input_matrix, filename):
    np.save(filename, input_matrix)

def transform_matrix_weight(input_matrix, length, scale=None):
    cout = input_matrix.shape[-1]
    weight_matrix = input_matrix.reshape(-1, cout)
    filled_matrix_b = np.zeros([weight_matrix.shape[0], weight_matrix.shape[1] * length], dtype=np.str)
    filled_matrix_bin = dec2bin(weight_matrix[:], length, scale)
    for i, b in enumerate(filled_matrix_bin):
        filled_matrix_b[:, i::length] = b
    return filled_matrix_b

def transform_matrix_activation_conv(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[2], input_shape[1] * length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i::length] = b.transpose()
    return filled_matrix_b

def transform_matrix_activation_fc(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[1], length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i] = b
    return filled_matrix_b
    
def stretch_input(input_matrix, window_size, stride=1):
    input_shape = input_matrix.shape
    row_num = (input_shape[2] - window_size) // stride + 1
    col_num = (input_shape[3] - window_size) // stride + 1
    assert((row_num - 1) * stride + window_size == input_shape[2])
    assert((col_num - 1) * stride + window_size == input_shape[3])
    item_num = row_num * col_num
    output_matrix = np.zeros((input_shape[0], item_num, input_shape[1]*window_size*window_size))
    iter = 0
    for i in range(row_num):
        for j in range(col_num):
            for b in range(input_shape[0]):
                output_matrix[b, iter, :] = input_matrix[b, :, i:i+window_size,j: j+window_size].transpose(1,2,0).reshape(input_shape[1]*window_size*window_size)
            iter += 1
    return output_matrix

def compute_scale_list(n):
    scale_list = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    scale_list.append(-base * delta)
    for _ in range(n-1):
        base /= 2
        scale_list.append(base * delta)
    return scale_list
    
def dec2bin(x, n, scale_list=None):
    if not scale_list:
        scale_list = compute_scale_list(n)
    y = x.copy()
    out = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    x_int = x/delta
    y[x_int>=0] = 0
    y[x_int< 0] = 1
    rest = x_int + base*y
    out.append(y.copy())
    for _ in range(n-1):
        base = base/2
        y[rest>=base] = 1
        y[rest< base]  = 0
        rest = rest - base * y
        out.append(y.copy())
    return out

def adjust_signed_computation(vector):
    n_batches = vector.shape[0]
    len_vec = vector.shape[1]
    n_vec = vector.shape[2] // bitsA
    assert(vector.shape[2] % bitsA == 0)
    in_vector = np.zeros((n_batches, len_vec, n_vec*(bitsA-1)), np.int)
    for b in range(n_batches):
        sliced_vectors = []
        for j in range(n_vec):
            sliced_vector = vector[b, :, j*bitsA:(j+1)*bitsA]
            for i in range(len_vec):
                if sliced_vector[i, 0] == 1:
                    sliced_vector[i, 0] = 0
                    for j in range(1, bitsA):
                        if sliced_vector[i, j] == 0:
                            sliced_vector[i, j] = -1
                        else:
                            sliced_vector[i, j] = 0
                    for j in range(bitsA - 1, -1, -1):
                        if sliced_vector[i, j] == 0:
                            sliced_vector[i, j] = -1
                            break
                        else:
                            sliced_vector[i, j] = 0
                    assert(sliced_vector[i, 0] == 0)
            sliced_vectors.append(sliced_vector[:, 1:])
        in_vector[b, :, :] = np.hstack(sliced_vectors)
    return in_vector

def transform_and_save_data():
    output_path = './layer_record/'

    scale_a = compute_scale_list(bitsA)
    scale_w = compute_scale_list(bitsW)

    with open(output_path + 'H.bin','rb') as fileH:
        IN = pickle.load(fileH)
    with open(output_path + 'W.bin','rb') as fileW:
        W = pickle.load(fileW)

    for i,(input,weight) in enumerate(zip(IN,W)):
        input_file_name = 'input_layer' + str(i) + '.npy'
        weight_file_name = 'weight_layer' + str(i) + '.npy'
        transformed_weight = transform_matrix_weight(weight, bitsW, scale_w)
        save_transformed_matrix(transformed_weight, output_path + weight_file_name)
        if len(weight.shape) > 2:
            k = weight.shape[0]
            transformed_activation = transform_matrix_activation_conv(stretch_input(input, k), bitsA, scale_a)
            save_transformed_matrix(transformed_activation, output_path + input_file_name)
        else:
            transformed_activation = transform_matrix_activation_fc(input, bitsA, scale_a)
            save_transformed_matrix(transformed_activation, output_path + input_file_name)
        signed_transformed_activation = adjust_signed_computation(transformed_activation)
        signed_input_file_name = 'signed_' + input_file_name
        save_transformed_matrix(signed_transformed_activation, output_path + signed_input_file_name)

def main():
    transform_and_save_data()

if __name__ == "__main__":
    main()
