import os
import numpy as np
import pickle

bitsA = 8
bitsW = 2

def save_transformed_matrix(input_matrix, filename):
    #assert(input_matrix.dtype == np.str)
    #np.savetxt(filename, input_matrix, delimiter=",", fmt='%s')
    np.save(filename, input_matrix)

def transform_matrix_weight(input_matrix, length, scale=None):
    cout = input_matrix.shape[-1]
    weight_matrix = input_matrix.reshape(-1, cout)
    filled_matrix_b = np.zeros([weight_matrix.shape[0], weight_matrix.shape[1] * length], dtype=np.str)
    filled_matrix_bin = dec2bin(weight_matrix[:], length, scale)
    for i, b in enumerate(filled_matrix_bin):
        filled_matrix_b[:, i::length] = b
    return filled_matrix_b

def transform_matrix_activation_conv(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[2], input_shape[1] * length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i::length] = b.transpose()
    return filled_matrix_b

def transform_matrix_activation_fc(input_matrix, length, scale=None):
    input_shape = input_matrix.shape
    filled_matrix_b = np.zeros([input_shape[0], input_shape[1], length], dtype=np.str)
    for batch in range(input_shape[0]):
        filled_matrix_bin = dec2bin(input_matrix[batch, :], length, scale)
        for i, b in enumerate(filled_matrix_bin):
            filled_matrix_b[batch, :, i] = b
    return filled_matrix_b
    
def stretch_input(input_matrix, window_size, stride=1):
    input_shape = input_matrix.shape
    row_num = (input_shape[2] - window_size) // stride + 1
    col_num = (input_shape[3] - window_size) // stride + 1
    assert((row_num - 1) * stride + window_size == input_shape[2])
    assert((col_num - 1) * stride + window_size == input_shape[3])
    item_num = row_num * col_num
    output_matrix = np.zeros((input_shape[0], item_num, input_shape[1]*window_size*window_size))
    iter = 0
    for i in range(row_num):
        for j in range(col_num):
            for b in range(input_shape[0]):
                output_matrix[b, iter, :] = input_matrix[b, :, i:i+window_size,j: j+window_size].transpose(1,2,0).reshape(input_shape[1]*window_size*window_size)
            iter += 1
    return output_matrix

def compute_scale_list(n):
    scale_list = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    scale_list.append(-base * delta)
    for _ in range(n-1):
        base /= 2
        scale_list.append(base * delta)
    return scale_list
    
def dec2bin(x, n, scale_list=None):
    if not scale_list:
        scale_list = compute_scale_list(n)
    y = x.copy()
    out = []
    delta = 1.0/(2**(n-1))
    base = 2**(n-1)
    x_int = x/delta
    y[x_int>=0] = 0
    y[x_int< 0] = 1
    rest = x_int + base*y
    out.append(y.copy())
    for _ in range(n-1):
        base = base/2
        y[rest>=base] = 1
        y[rest< base]  = 0
        rest = rest - base * y
        out.append(y.copy())
    return out

def transform_and_save_data():
    output_path = './layer_record/'
    #if os.path.exists('./layer_record/trace_command.sh'):
    #    os.remove('./layer_record/trace_command.sh')
    #f = open('./layer_record/trace_command.sh', "a")
    #f.write('./NeuroSIM/main ./NeuroSIM/NetWork.csv '+str(weight_length)+' '+str(input_length)+' ')

    scale_a = compute_scale_list(bitsA)
    scale_w = compute_scale_list(bitsW)

    with open(output_path + 'H.bin','rb') as fileH:
        IN = pickle.load(fileH)
    with open(output_path + 'W.bin','rb') as fileW:
        W = pickle.load(fileW)

    for i,(input,weight) in enumerate(zip(IN,W)):
        input_file_name = 'input_layer' + str(i) + '.npy'
        weight_file_name = 'weight_layer' + str(i) + '.npy'
        #f.write(output_path + weight_file_name+' '+output_path + input_file_name+' ')
        transformed_weight = transform_matrix_weight(weight, bitsW, scale_w)
        save_transformed_matrix(transformed_weight, output_path + weight_file_name)
        if len(weight.shape) > 2:
            k = weight.shape[0]
            transformed_activation = transform_matrix_activation_conv(stretch_input(input, k), bitsA, scale_a)
            save_transformed_matrix(transformed_activation, output_path + input_file_name)
        else:
            transformed_activation = transform_matrix_activation_fc(input, bitsA, scale_a)
            save_transformed_matrix(transformed_activation, output_path + input_file_name)
    #f.close()
    #call(["/bin/bash", "./layer_record/trace_command.sh"])

def main():
    transform_and_save_data()

if __name__ == "__main__":
    main()